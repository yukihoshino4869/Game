
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>マリオ風ゲーム完全版</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; background: #87ceeb; }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="400"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let state = "title";
let keys = {};
let player;
let bullets = [];
let enemies = [];
let blocks = [];
let flag;
let jumpCount = 0;

const gravity = 0.5;
const groundY = 350;
const mapWidth = 2000;

document.addEventListener("keydown", e => {
  keys[e.key] = true;
  if (e.key === "Enter") {
    if (state === "title" || state === "gameover") startGame();
    else if (state === "stageclear") state = "title";
  }
  if (state === "playing" && e.key === " ") shoot();
});
document.addEventListener("keyup", e => keys[e.key] = false);

function startGame() {
  state = "playing";
  player = { x: 50, y: groundY - 20, vx: 0, vy: 0, width: 20, height: 20, onGround: true };
  jumpCount = 0;
  bullets = [];
  enemies = [];
  blocks = [];
  const enemyCount = 5;
  for (let i = 0; i < enemyCount; i++) {
    enemies.push({
      x: 400 + i * 200,
      y: groundY - 20,
      vx: -1,
      width: 20,
      height: 20
    });
  }
  // ランダムな障害物を生成
  for (let i = 0; i < 10; i++) {
    let x = 200 + Math.floor(Math.random() * (mapWidth - 300));
    let y = 250 + Math.floor(Math.random() * 80);
    blocks.push({ x, y, width: 50, height: 20 });
  }
  flag = { x: 1800, y: groundY - 80, width: 10, height: 80 };
  loop();
}

function shoot() {
  bullets.push({
    x: player.x + player.width / 2,
    y: player.y + player.height / 2,
    vx: 5,
    width: 5,
    height: 5
  });
}

function isCollide(a, b) {
  return a.x < b.x + b.width && a.x + a.width > b.x &&
         a.y < b.y + b.height && a.y + a.height > b.y;
}

function update() {
  if (state !== "playing") return;

  player.vx = 0;
  if (keys["a"]) player.vx = -2;
  if (keys["d"]) player.vx = 2;

  if ((keys["w"] || keys["ArrowUp"]) && jumpCount < 2) {
    if (player.onGround || jumpCount < 2) {
      player.vy = -10;
      player.onGround = false;
      jumpCount++;
    }
  }

  player.x += player.vx;
  player.vy += gravity;
  player.y += player.vy;

  // 壁との衝突判定
  blocks.forEach(b => {
    if (isCollide(player, b)) {
      if (player.vy > 0 && player.y + player.height <= b.y + player.vy) {
        player.y = b.y - player.height;
        player.vy = 0;
        player.onGround = true;
        jumpCount = 0;
      } else if (player.vx > 0 && player.x + player.width <= b.x + player.vx) {
        player.x = b.x - player.width;
      } else if (player.vx < 0 && player.x >= b.x + b.width + player.vx) {
        player.x = b.x + b.width;
      }
    }
  });

  if (player.y >= groundY - player.height) {
    player.y = groundY - player.height;
    player.vy = 0;
    player.onGround = true;
    jumpCount = 0;
  }

  if (player.x < 0) player.x = 0;
  if (player.x + player.width > mapWidth) player.x = mapWidth - player.width;

  bullets.forEach(b => b.x += b.vx);
  bullets = bullets.filter(b => b.x < mapWidth);

  enemies.forEach(e => {
    e.x += e.vx;
    if (e.x < 0 || e.x > mapWidth - e.width) e.vx *= -1;
  });

  bullets.forEach(b => {
    enemies.forEach((e, i) => {
      if (isCollide(b, e)) enemies.splice(i, 1);
    });
  });

  enemies.forEach(e => {
    if (isCollide(player, e)) {
      if (player.vy > 0) {
        player.vy = -8;
        enemies = enemies.filter(en => en !== e);
      } else {
        state = "gameover";
      }
    }
  });

  if (isCollide(player, flag)) state = "stageclear";
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (state === "title") {
    ctx.fillStyle = "blue";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "white";
    ctx.font = "48px sans-serif";
    ctx.fillText("demo", 340, 180);
    ctx.font = "20px sans-serif";
    ctx.fillText("Press Enter to Start", 310, 220);
    return;
  }

  if (state === "gameover") {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "white";
    ctx.font = "40px sans-serif";
    ctx.fillText("Game Over", 300, 200);
    ctx.font = "20px sans-serif";
    ctx.fillText("Press Enter to Restart", 280, 240);
    return;
  }

  if (state === "stageclear") {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "white";
    ctx.font = "40px sans-serif";
    ctx.fillText("Stage Clear!", 290, 200);
    ctx.font = "20px sans-serif";
    ctx.fillText("Press Enter to Return", 280, 240);
    return;
  }

  let camX = player.x - 400;
  if (camX < 0) camX = 0;
  if (camX > mapWidth - canvas.width) camX = mapWidth - canvas.width;

  ctx.fillStyle = "green";
  ctx.fillRect(0 - camX, groundY, mapWidth, 50);

  ctx.fillStyle = "blue";
  blocks.forEach(b => ctx.fillRect(b.x - camX, b.y, b.width, b.height));

  ctx.fillStyle = "black";
  ctx.fillRect(player.x - camX, player.y, player.width, player.height);

  ctx.fillStyle = "yellow";
  bullets.forEach(b => ctx.fillRect(b.x - camX, b.y, b.width, b.height));

  ctx.fillStyle = "red";
  enemies.forEach(e => ctx.fillRect(e.x - camX, e.y, e.width, e.height));

  ctx.fillStyle = "white";
  ctx.fillRect(flag.x - camX, flag.y, flag.width, flag.height);
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
draw(); // 初回描画（タイトル）
</script>
</body>
</html>
